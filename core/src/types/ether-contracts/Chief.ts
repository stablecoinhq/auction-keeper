/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export interface ChiefInterface extends utils.Interface {
  functions: {
    "GOV()": FunctionFragment;
    "IOU()": FunctionFragment;
    "MAX_YAYS()": FunctionFragment;
    "approvals(address)": FunctionFragment;
    "authority()": FunctionFragment;
    "canCall(address,address,bytes4)": FunctionFragment;
    "deposits(address)": FunctionFragment;
    "etch(address[])": FunctionFragment;
    "free(uint256)": FunctionFragment;
    "getCapabilityRoles(address,bytes4)": FunctionFragment;
    "getUserRoles(address)": FunctionFragment;
    "hasUserRole(address,uint8)": FunctionFragment;
    "hat()": FunctionFragment;
    "isCapabilityPublic(address,bytes4)": FunctionFragment;
    "isUserRoot(address)": FunctionFragment;
    "last(address)": FunctionFragment;
    "launch()": FunctionFragment;
    "lift(address)": FunctionFragment;
    "live()": FunctionFragment;
    "lock(uint256)": FunctionFragment;
    "owner()": FunctionFragment;
    "setAuthority(address)": FunctionFragment;
    "setOwner(address)": FunctionFragment;
    "setPublicCapability(address,bytes4,bool)": FunctionFragment;
    "setRoleCapability(uint8,address,bytes4,bool)": FunctionFragment;
    "setRootUser(address,bool)": FunctionFragment;
    "setUserRole(address,uint8,bool)": FunctionFragment;
    "slates(bytes32,uint256)": FunctionFragment;
    "vote(bytes32)": FunctionFragment;
    "vote(address[])": FunctionFragment;
    "votes(address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "GOV"
      | "IOU"
      | "MAX_YAYS"
      | "approvals"
      | "authority"
      | "canCall"
      | "deposits"
      | "etch"
      | "free"
      | "getCapabilityRoles"
      | "getUserRoles"
      | "hasUserRole"
      | "hat"
      | "isCapabilityPublic"
      | "isUserRoot"
      | "last"
      | "launch"
      | "lift"
      | "live"
      | "lock"
      | "owner"
      | "setAuthority"
      | "setOwner"
      | "setPublicCapability"
      | "setRoleCapability"
      | "setRootUser"
      | "setUserRole"
      | "slates"
      | "vote(bytes32)"
      | "vote(address[])"
      | "votes"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "GOV", values?: undefined): string;
  encodeFunctionData(functionFragment: "IOU", values?: undefined): string;
  encodeFunctionData(functionFragment: "MAX_YAYS", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "approvals",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "authority", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "canCall",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "deposits",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "etch",
    values: [PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "free",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getCapabilityRoles",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserRoles",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "hasUserRole",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "hat", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "isCapabilityPublic",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "isUserRoot",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "last",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "launch", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "lift",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "live", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "lock",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "setAuthority",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setOwner",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setPublicCapability",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setRoleCapability",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setRootUser",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setUserRole",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "slates",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "vote(bytes32)",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "vote(address[])",
    values: [PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "votes",
    values: [PromiseOrValue<string>]
  ): string;

  decodeFunctionResult(functionFragment: "GOV", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "IOU", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "MAX_YAYS", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "approvals", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "authority", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "canCall", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "deposits", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "etch", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "free", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getCapabilityRoles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserRoles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "hasUserRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "hat", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isCapabilityPublic",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isUserRoot", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "last", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "launch", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "lift", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "live", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "lock", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setAuthority",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setOwner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setPublicCapability",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setRoleCapability",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setRootUser",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setUserRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "slates", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "vote(bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "vote(address[])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "votes", data: BytesLike): Result;

  events: {
    "Etch(bytes32)": EventFragment;
    "LogNote(bytes4,address,bytes32,bytes32,uint256,bytes)": EventFragment;
    "LogSetAuthority(address)": EventFragment;
    "LogSetOwner(address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Etch"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogNote"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogSetAuthority"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogSetOwner"): EventFragment;
}

export interface EtchEventObject {
  slate: string;
}
export type EtchEvent = TypedEvent<[string], EtchEventObject>;

export type EtchEventFilter = TypedEventFilter<EtchEvent>;

export interface LogNoteEventObject {
  sig: string;
  guy: string;
  foo: string;
  bar: string;
  wad: BigNumber;
  fax: string;
}
export type LogNoteEvent = TypedEvent<
  [string, string, string, string, BigNumber, string],
  LogNoteEventObject
>;

export type LogNoteEventFilter = TypedEventFilter<LogNoteEvent>;

export interface LogSetAuthorityEventObject {
  authority: string;
}
export type LogSetAuthorityEvent = TypedEvent<
  [string],
  LogSetAuthorityEventObject
>;

export type LogSetAuthorityEventFilter = TypedEventFilter<LogSetAuthorityEvent>;

export interface LogSetOwnerEventObject {
  owner: string;
}
export type LogSetOwnerEvent = TypedEvent<[string], LogSetOwnerEventObject>;

export type LogSetOwnerEventFilter = TypedEventFilter<LogSetOwnerEvent>;

export interface Chief extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ChiefInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    GOV(overrides?: CallOverrides): Promise<[string]>;

    IOU(overrides?: CallOverrides): Promise<[string]>;

    MAX_YAYS(overrides?: CallOverrides): Promise<[BigNumber]>;

    approvals(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    authority(overrides?: CallOverrides): Promise<[string]>;

    canCall(
      caller: PromiseOrValue<string>,
      code: PromiseOrValue<string>,
      sig: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    deposits(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    etch(
      yays: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    free(
      wad: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getCapabilityRoles(
      code: PromiseOrValue<string>,
      sig: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getUserRoles(
      who: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    hasUserRole(
      who: PromiseOrValue<string>,
      role: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    hat(overrides?: CallOverrides): Promise<[string]>;

    isCapabilityPublic(
      code: PromiseOrValue<string>,
      sig: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isUserRoot(
      who: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    last(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    launch(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    lift(
      whom: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    live(overrides?: CallOverrides): Promise<[boolean]>;

    lock(
      wad: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    setAuthority(
      authority_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setOwner(
      owner_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setPublicCapability(
      code: PromiseOrValue<string>,
      sig: PromiseOrValue<BytesLike>,
      enabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setRoleCapability(
      role: PromiseOrValue<BigNumberish>,
      code: PromiseOrValue<string>,
      sig: PromiseOrValue<BytesLike>,
      enabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setRootUser(
      who: PromiseOrValue<string>,
      enabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setUserRole(
      who: PromiseOrValue<string>,
      role: PromiseOrValue<BigNumberish>,
      enabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    slates(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    "vote(bytes32)"(
      slate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "vote(address[])"(
      yays: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    votes(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string]>;
  };

  GOV(overrides?: CallOverrides): Promise<string>;

  IOU(overrides?: CallOverrides): Promise<string>;

  MAX_YAYS(overrides?: CallOverrides): Promise<BigNumber>;

  approvals(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  authority(overrides?: CallOverrides): Promise<string>;

  canCall(
    caller: PromiseOrValue<string>,
    code: PromiseOrValue<string>,
    sig: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  deposits(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  etch(
    yays: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  free(
    wad: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getCapabilityRoles(
    code: PromiseOrValue<string>,
    sig: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  getUserRoles(
    who: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string>;

  hasUserRole(
    who: PromiseOrValue<string>,
    role: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  hat(overrides?: CallOverrides): Promise<string>;

  isCapabilityPublic(
    code: PromiseOrValue<string>,
    sig: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isUserRoot(
    who: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  last(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  launch(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  lift(
    whom: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  live(overrides?: CallOverrides): Promise<boolean>;

  lock(
    wad: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  owner(overrides?: CallOverrides): Promise<string>;

  setAuthority(
    authority_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setOwner(
    owner_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setPublicCapability(
    code: PromiseOrValue<string>,
    sig: PromiseOrValue<BytesLike>,
    enabled: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setRoleCapability(
    role: PromiseOrValue<BigNumberish>,
    code: PromiseOrValue<string>,
    sig: PromiseOrValue<BytesLike>,
    enabled: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setRootUser(
    who: PromiseOrValue<string>,
    enabled: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setUserRole(
    who: PromiseOrValue<string>,
    role: PromiseOrValue<BigNumberish>,
    enabled: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  slates(
    arg0: PromiseOrValue<BytesLike>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  "vote(bytes32)"(
    slate: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "vote(address[])"(
    yays: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  votes(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string>;

  callStatic: {
    GOV(overrides?: CallOverrides): Promise<string>;

    IOU(overrides?: CallOverrides): Promise<string>;

    MAX_YAYS(overrides?: CallOverrides): Promise<BigNumber>;

    approvals(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    authority(overrides?: CallOverrides): Promise<string>;

    canCall(
      caller: PromiseOrValue<string>,
      code: PromiseOrValue<string>,
      sig: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    deposits(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    etch(
      yays: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<string>;

    free(
      wad: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    getCapabilityRoles(
      code: PromiseOrValue<string>,
      sig: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    getUserRoles(
      who: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;

    hasUserRole(
      who: PromiseOrValue<string>,
      role: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    hat(overrides?: CallOverrides): Promise<string>;

    isCapabilityPublic(
      code: PromiseOrValue<string>,
      sig: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isUserRoot(
      who: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    last(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    launch(overrides?: CallOverrides): Promise<void>;

    lift(
      whom: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    live(overrides?: CallOverrides): Promise<boolean>;

    lock(
      wad: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    owner(overrides?: CallOverrides): Promise<string>;

    setAuthority(
      authority_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setOwner(
      owner_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setPublicCapability(
      code: PromiseOrValue<string>,
      sig: PromiseOrValue<BytesLike>,
      enabled: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setRoleCapability(
      role: PromiseOrValue<BigNumberish>,
      code: PromiseOrValue<string>,
      sig: PromiseOrValue<BytesLike>,
      enabled: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setRootUser(
      who: PromiseOrValue<string>,
      enabled: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setUserRole(
      who: PromiseOrValue<string>,
      role: PromiseOrValue<BigNumberish>,
      enabled: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    slates(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    "vote(bytes32)"(
      slate: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    "vote(address[])"(
      yays: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<string>;

    votes(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;
  };

  filters: {
    "Etch(bytes32)"(slate?: PromiseOrValue<BytesLike> | null): EtchEventFilter;
    Etch(slate?: PromiseOrValue<BytesLike> | null): EtchEventFilter;

    "LogNote(bytes4,address,bytes32,bytes32,uint256,bytes)"(
      sig?: PromiseOrValue<BytesLike> | null,
      guy?: PromiseOrValue<string> | null,
      foo?: PromiseOrValue<BytesLike> | null,
      bar?: PromiseOrValue<BytesLike> | null,
      wad?: null,
      fax?: null
    ): LogNoteEventFilter;
    LogNote(
      sig?: PromiseOrValue<BytesLike> | null,
      guy?: PromiseOrValue<string> | null,
      foo?: PromiseOrValue<BytesLike> | null,
      bar?: PromiseOrValue<BytesLike> | null,
      wad?: null,
      fax?: null
    ): LogNoteEventFilter;

    "LogSetAuthority(address)"(
      authority?: PromiseOrValue<string> | null
    ): LogSetAuthorityEventFilter;
    LogSetAuthority(
      authority?: PromiseOrValue<string> | null
    ): LogSetAuthorityEventFilter;

    "LogSetOwner(address)"(
      owner?: PromiseOrValue<string> | null
    ): LogSetOwnerEventFilter;
    LogSetOwner(owner?: PromiseOrValue<string> | null): LogSetOwnerEventFilter;
  };

  estimateGas: {
    GOV(overrides?: CallOverrides): Promise<BigNumber>;

    IOU(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_YAYS(overrides?: CallOverrides): Promise<BigNumber>;

    approvals(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    authority(overrides?: CallOverrides): Promise<BigNumber>;

    canCall(
      caller: PromiseOrValue<string>,
      code: PromiseOrValue<string>,
      sig: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    deposits(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    etch(
      yays: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    free(
      wad: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getCapabilityRoles(
      code: PromiseOrValue<string>,
      sig: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getUserRoles(
      who: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hasUserRole(
      who: PromiseOrValue<string>,
      role: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hat(overrides?: CallOverrides): Promise<BigNumber>;

    isCapabilityPublic(
      code: PromiseOrValue<string>,
      sig: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isUserRoot(
      who: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    last(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    launch(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    lift(
      whom: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    live(overrides?: CallOverrides): Promise<BigNumber>;

    lock(
      wad: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    setAuthority(
      authority_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setOwner(
      owner_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setPublicCapability(
      code: PromiseOrValue<string>,
      sig: PromiseOrValue<BytesLike>,
      enabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setRoleCapability(
      role: PromiseOrValue<BigNumberish>,
      code: PromiseOrValue<string>,
      sig: PromiseOrValue<BytesLike>,
      enabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setRootUser(
      who: PromiseOrValue<string>,
      enabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setUserRole(
      who: PromiseOrValue<string>,
      role: PromiseOrValue<BigNumberish>,
      enabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    slates(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "vote(bytes32)"(
      slate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "vote(address[])"(
      yays: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    votes(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    GOV(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    IOU(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MAX_YAYS(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    approvals(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    authority(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    canCall(
      caller: PromiseOrValue<string>,
      code: PromiseOrValue<string>,
      sig: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    deposits(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    etch(
      yays: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    free(
      wad: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getCapabilityRoles(
      code: PromiseOrValue<string>,
      sig: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getUserRoles(
      who: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hasUserRole(
      who: PromiseOrValue<string>,
      role: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hat(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isCapabilityPublic(
      code: PromiseOrValue<string>,
      sig: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isUserRoot(
      who: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    last(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    launch(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    lift(
      whom: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    live(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lock(
      wad: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setAuthority(
      authority_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setOwner(
      owner_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setPublicCapability(
      code: PromiseOrValue<string>,
      sig: PromiseOrValue<BytesLike>,
      enabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setRoleCapability(
      role: PromiseOrValue<BigNumberish>,
      code: PromiseOrValue<string>,
      sig: PromiseOrValue<BytesLike>,
      enabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setRootUser(
      who: PromiseOrValue<string>,
      enabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setUserRole(
      who: PromiseOrValue<string>,
      role: PromiseOrValue<BigNumberish>,
      enabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    slates(
      arg0: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "vote(bytes32)"(
      slate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "vote(address[])"(
      yays: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    votes(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
